"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const apputils_1 = require("@jupyterlab/apputils");
const statusbar_1 = require("@jupyterlab/statusbar");
const _1 = require(".");
const widgets_1 = require("@phosphor/widgets");
/**
 * A pure function that returns a tsx component for an editor syntax item.
 *
 * @param props: the props for the component.
 *
 * @returns an editor syntax component.
 */
function EditorSyntaxComponent(props) {
    return react_1.default.createElement(statusbar_1.TextItem, { source: props.mode, onClick: props.handleClick });
}
/**
 * StatusBar item to change the language syntax highlighting of the file editor.
 */
class EditorSyntaxStatus extends apputils_1.VDomRenderer {
    /**
     * Construct a new VDomRenderer for the status item.
     */
    constructor(opts) {
        super();
        /**
         * Create a menu for selecting the mode of the editor.
         */
        this._handleClick = () => {
            const modeMenu = new widgets_1.Menu({ commands: this._commands });
            let command = 'codemirror:change-mode';
            if (this._popup) {
                this._popup.dispose();
            }
            _1.Mode.getModeInfo()
                .sort((a, b) => {
                let aName = a.name || '';
                let bName = b.name || '';
                return aName.localeCompare(bName);
            })
                .forEach(spec => {
                if (spec.mode.indexOf('brainf') === 0) {
                    return;
                }
                let args = {
                    insertSpaces: true,
                    name: spec.name
                };
                modeMenu.addItem({
                    command,
                    args
                });
            });
            this._popup = statusbar_1.showPopup({
                body: modeMenu,
                anchor: this,
                align: 'left'
            });
        };
        this._popup = null;
        this.model = new EditorSyntaxStatus.Model();
        this._commands = opts.commands;
        this.addClass(statusbar_1.interactiveItem);
        this.title.caption = 'Change text editor syntax highlighting';
    }
    /**
     * Render the status item.
     */
    render() {
        if (!this.model) {
            return null;
        }
        return (react_1.default.createElement(EditorSyntaxComponent, { mode: this.model.mode, handleClick: this._handleClick }));
    }
}
exports.EditorSyntaxStatus = EditorSyntaxStatus;
/**
 * A namespace for EditorSyntax statics.
 */
(function (EditorSyntaxStatus) {
    /**
     * A VDomModel for the current editor/mode combination.
     */
    class Model extends apputils_1.VDomModel {
        constructor() {
            super(...arguments);
            /**
             * If the editor mode changes, update the model.
             */
            this._onMIMETypeChange = (mode, change) => {
                const oldMode = this._mode;
                const spec = _1.Mode.findByMIME(change.newValue);
                this._mode = spec.name || spec.mode;
                this._triggerChange(oldMode, this._mode);
            };
            this._mode = '';
            this._editor = null;
        }
        /**
         * The current mode for the editor. If no editor is present,
         * returns the empty string.
         */
        get mode() {
            return this._mode;
        }
        /**
         * The current editor for the application editor tracker.
         */
        get editor() {
            return this._editor;
        }
        set editor(editor) {
            const oldEditor = this._editor;
            if (oldEditor !== null) {
                oldEditor.model.mimeTypeChanged.disconnect(this._onMIMETypeChange);
            }
            const oldMode = this._mode;
            this._editor = editor;
            if (this._editor === null) {
                this._mode = '';
            }
            else {
                const spec = _1.Mode.findByMIME(this._editor.model.mimeType);
                this._mode = spec.name || spec.mode;
                this._editor.model.mimeTypeChanged.connect(this._onMIMETypeChange);
            }
            this._triggerChange(oldMode, this._mode);
        }
        /**
         * Trigger a rerender of the model.
         */
        _triggerChange(oldState, newState) {
            if (oldState !== newState) {
                this.stateChanged.emit(void 0);
            }
        }
    }
    EditorSyntaxStatus.Model = Model;
})(EditorSyntaxStatus = exports.EditorSyntaxStatus || (exports.EditorSyntaxStatus = {}));
